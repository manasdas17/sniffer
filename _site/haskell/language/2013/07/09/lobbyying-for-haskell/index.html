<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="None worth writing.">
    <title>Lobbying for Haskell </title>
    <meta name="author" content="Dilawar Singh" />
    <link rel="stylesheet" href="https://github.com/themes/minimal/stylesheets/styles.css">
 <style>
      header { zoom: 1.0; width: 150px}
      header h1 { margin-bottom: 5px; }
      header h1 a { color: #494949; font-weight: bold; }
      header h3 { margin-top: 20px; margin-bottom: 5px; }
      header p.view { margin-bottom: 5px; }
      header p.view small { padding-top: 2px; }
      header ul {
        zoom: 0.7;
        margin-top: 25px;
      }
      section { width: 600px }
      section p { margin-top: 10px; }
      section h1 { margin-bottom: 15px; }
      section h2 { margin-bottom: 10px; }
      section h2 { margin-bottom: 10px; }
      footer { bottom: 20px; }
      footer p { margin-bottom: 5px; }
      .half-width {
        float: left;
        width: 100px;
        list-style: none;
        padding: 5px;
        margin: 7px;
        margin-bottom: 10px;
      }
      .half-width h4 {
        margin-bottom: 5px;
      }
      .half-width ul {
        padding-left: 0;
      }
      .half-width ul li {
        list-style: inside;
        font-size: 15px;
      }
      .clear-fix {
        clear: both;
      }
    </style>
    <script src="https://github.com/themes/minimal/javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
</head>

<body>
    <div class="wrapper">
        <header>
        <h1><a href="/">Notes</a></h1>
        <p class="view"> <img src= "http://dilawar.github.io/images/pic_enhanced.jpg"
            alt="dilawar" height="150" width="150" /> </p>
        <p class="view"><a href="/projects/index.html">Open Source Projects <small>Might be useful to you</small></a></p>
        <p class="view"><a target="_blank"
            href="http://www.cen.iitb.ac.in/">Masters<small>Microelectronics and
                VLSI</small></a> 
        </p>
        <p class="view"><a target="_blank"
            href="http://www.ee.iitb.ac.in/~hpc">Ph. D.</a><small>Abandoned
            after 3 years</small>
        </p>
        <p class="view"><a target="_blank"
            href="http://www.ncbs.res.in/bhalla">Research Fellow <small>Moose,
                The Neural Simulator</small> </a> 
        </p>
        <p class="view"><a target="_blank"
            href="http://dilawarrajput.wordpress.com">Blog <small>This much I
                know</small></a> 
        </p>

        
        </header>

        <footer>
        </footer>

    <section id="post">
    <h1>Lobbying for Haskell  </h1>
<div class="content">
  <blockquote><p>... but one must not be surprised if outsiders don't take Haskell too seriously... [We] say a lot about what functional programming isn't: It has no assignment, no side effect, no flow of control but not much about what it is. The functional programmer sounds rather a medieval monk, denying himself the pleasures of life in hope that it will make him virtuous. To those interested in material benefits, these 'advantages' are totally unconvincing.</p></blockquote>

<p>-- "Why functional programming matters"</p>

<p>John Hughes, The Computer Journal, 1989</p>

<p>If someone comes to you with a new programming language, it is the time to run in the other direction. Who needs one more language; don't we have millions of them already? Besides, if I can do something in a language I know well with the help of libraries, should I invest my time in learning a new language? A young student does not have such worldly concerns. He can be easily excited about a new language.</p>

<p>Why functional programming language? And why Haskell? Computer science people have their own reasons on why they prefer one language over other. But what about others, especially Electrical Engineering people, who can be equally, and often are, equally concerned about languages.</p>

<p>Electrical engineers are usually deals with hardware and the way things gets executed on it. They prefer C/C++ to explore their hardware and rightfully so. I doubt if any language can beat it on 'fetch and execute' type of processors (except for assembly). There is also designing and modeling side of electrical engineering. Here we have HDLs, and some other languages. Python is a versatile language designed for convenience: no seg-faults and core dumps. Moving from C to Python is relatively easy. Both languages have same type of flow. C/C++ is often taught in all engineering branches; python can be learned with little effort. Its an incredibly good combination.</p>

<p>In functional programming languages, most if not all things are functions. A function takes functions as argument and return a function as result. In C/C++, to do this, you have to use function pointers imaginatively. It's a loose definition which might irritate those who have a theoretically neat mind. Nonetheless, it will serve our purpose for this informal discussion. It's the ease with which we can 'glue' functions together to create a new function which makes functional programming attractive. You can go through a classic work, 'Structure and Interpretation of Computer Programs' to get the taste of functional programming. They have used Scheme, a dialect of Lisp language which is a functional programming language, old as Fortran. Moving from Lisp or Scheme to Haskell is rather simple. But learning Haskell can be challenging for those who are from C world. Many of them usually give up when they are confronted with monad.</p>

<p>We can list out some benefits of Haskell over C/C++. The cost is speed and memory. I am not suggesting that Haskell is always slow. It can be very fast, and sometimes as fast as C. Both Python and Haskell drops into C to do computationally expensive tasks. While there is little you can do in pure Python to make things faster, Haskell provides many opportunities for optimization at its back-end. Learning to optimize the Haskell code can be challenging. A lot of work has been done on these directions.</p>

<p>The beauty of Haskell (or any functional programming language) lies in that fact that it captures the idea of recursion most naturally. Once you know the syntax, writing recursive functions are extremely easy. This is usually their selling point: recursive functions and recursive data-structures are easier to handle. Python has also borrowed some of these functional programming features such as list-comprehension and lambda functions (anonymous function). The C++ 2011 standard has Lambda function. That should be the proof enough of its syntactic beauty.</p>

<p>The core of Haskell is small. If lambda calculus -- which is Turning complete -- has only two operations and can model any computation then why should core of any language have more? Clean syntax and a small core are beneficial for those who infer the logic by looking at the program. Translation of Haskell code to something else should be easier. Moreover as parallel hardwares are becoming common-place, functional languages will increase in their stature. Figuring out parallel component in C/C++ is not easy. Programmer has to figure it out and code it by himself. People have found that it is relatively much easier for Haskell compiler to figure the parallelism out by itself.</p>

<p>If you have ever written a large program (say a thousand line of code) then you must have spent more time debugging the application than coding it. In fact, a saying in programming community goes, 'Anyone can code, it takes a programmer to debug'. Haskell reduces chances of a programmer creating bugs significantly by its strong type system. In Electrical Engineering, no one really gives a damn if a language has strong type-system. Who cares if VHDL have a stronger type-system than Verilog? You should ask your CS friend about it and its merit. A simple example might throw some light on it.</p>

<p>typedef speed_t double;
typedef acceleration_t double;
typedef distance_t double;</p>

<p>speed_t a =10.0;
acceleration_t b =9.8;
distance_t c = a + b;</p>

<p>Now it is illegal to add speed and acceleration. But it is a legal piece of code in C. Such bugs will be incredibly hard to locate in C. An equivalent code in Haskell would not compile at all. The operator '+' demands that a and b should be of same type which they are not. Since Haskell check types at compile type (unlike python which checks it at run-time), it will easily catch it (and can easily irritate you).</p>

<p>People talk about many other benefits Haskell provides to a programmer. One of them is that one has to type fewer lines. This is certainly true but what is doubtful if producing n line of code in Haskell is less time consuming that writing its equivalent in Python.</p>

<p>My own experience with Haskell language are of mixed kind.Â  When you are working with recursive stuff, Haskell is very pleasant to code in. When it comes to non-recursive stuff such as graph, Haskell can become painfully slow. It has to convert graph (which is a non-recursive data-structure) to an equivalent recursive structure which takes a lot of memory. You will overflow your stack more often in Haskell than in Python or C. Hardcore algorithmic people who deals with large graphs will not find it very exciting.</p>

<p>I'd recommend Haskell not because you are going to use to use it in your professional life. Most probably you won't. It would be a worthy investment just to learn the most rudimentary Haskell. Haskell makes you think and reason at very high level. Mistakes made at high levels become easily apparent in Haskell then they would be in C or Python. Moreover, once you have become efficient in Haskell, breaking your design in smaller pieces and gluing them together will come naturally to you. If writing modular program is a virtue than Haskell is perhaps one of the best language around. Breaking and gluing functions is the essence of of functional programming; it is made easier in Haskell. Learning Haskell will make you a better programmer even if you are not coding in Haskell.</p>

<p>You can also try Scheme. Best thing about Scheme is that you can call yourself a 'schemer' who schemes everyday, which is million times cooler than calling yourself a 'Haskeller'.</p>

<p>Resources :</p>

<p>[1] Prof. Sanyal <a href="http://www.cse.iitb.ac.in/%7Eas/fpcourse/fpcourse.html">page on Haskell</a>. Check out the problem sheet.
[2] <a href="http://book.realworldhaskell.org/read/">Real world Haskell</a>. This is a really good book to start with.
[3] <a href="http://learnyouahaskell.com/">http://learnyouahaskell.com/</a> . Read it at your own risk. Sometimes he says much about nothing.
[4] Structure and interpretation of computer program. This old classic is freely available. Still a great book to learn about computer programs.</p>

<p>--
Dilawar
EE, IITB</p>

<h6>Related articles</h6>

<ul>
<li><a href="http://drtallman.wordpress.com/2013/06/19/haskell-mind-blowing/">Haskell - Mind Blowing</a> (drtallman.wordpress.com)</li>
</ul>


</div>

<div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li> <a href="/numerical%20computation/2014/01/30/Coding-With-Floats/">Coding with float</a></li>
    
      <li> <a href="/noguinomousenoproblem/2014/01/29/Using-mutt/">Using mutt, saving password and writing mail in markdown</a></li>
    
      <li> <a href="/[%22tutorial%22,%20%22literate%20programming%22]/2013/10/30/Python-frontend-for-noweb/">Python front-end for Noweb literate tool</a></li>
    
  </ul>
</div>

<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

<!-- Google analytic -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47774588-1', 'dilawar.github.io');
    ga('send', 'pageview');
</script>

<div id="comment">
  
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'dilawarblog'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
   })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>



    </section>

    <!-- Latex in post -->
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- Google analytic -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-47774588-1', 'dilawar.github.io');
        ga('send', 'pageview');
    </script>
</body>
</html>
